{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "Author: Somtochukwu Nnajide\n",
    "Title: Employee Optimisation Genetic Algorithm\n",
    "Last Modified: 26/10/2024\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Libraries\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 137,
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "import service_simulator\n",
    "import operator\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Genetic Algorithm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 179,
   "metadata": {},
   "outputs": [],
   "source": [
    "class GeneticAlgorithm:\n",
    "    def __init__(self, population_size, num_generations, mutation_rate, patience, verbose):\n",
    "        self.population_size = population_size\n",
    "        self.num_generations = num_generations\n",
    "        self.mutation_rate = mutation_rate\n",
    "        self.patience = patience\n",
    "        self.verbose = verbose\n",
    "\n",
    "        self.population = []\n",
    "        self.fitness = []\n",
    "        self.parents = []\n",
    "        self.list_of_best_fitness = []\n",
    "\n",
    "        self.patience_counter = 0\n",
    "        self.parent_selection = 0\n",
    "        self.crossover_selection = 0\n",
    "        self.num_parents = self.population_size // 2\n",
    "        self.tournament_size = self.population_size // 4\n",
    "        self.best_fitness = 1000000\n",
    "        self.best_found_at = -1\n",
    "        self.best_individual = None\n",
    "\n",
    "        self.parent_selection_techniques = {\n",
    "            1:\"Elitism\",\n",
    "            2:\"Roulette Wheel\",\n",
    "            3:\"Tournament Selection\",\n",
    "            4:\"Rank Selection\"\n",
    "        }\n",
    "\n",
    "        self.crossover_selection_techniques = {\n",
    "            1:\"Single-point crossover\",\n",
    "            2:\"Two-point crossover\",\n",
    "            3:\"Uniform crossover\"\n",
    "        }\n",
    "\n",
    "        self.menu()\n",
    "        self.initialisePopulation()\n",
    "\n",
    "        print(\"\\nFinished initialisation\\n\")\n",
    "    \n",
    "    def menu(self):\n",
    "        \"\"\"\n",
    "        Genetic algorithm menu\n",
    "\n",
    "        -> Parent technique\n",
    "        \"\"\"\n",
    "        print(\"Genetic Algorithm Initialisation Menu\\n\")\n",
    "        print(\"Parent selection options (1-4)\\n1. Elitism\\n2. Roulette Wheel\\n3. Tournament selection\\n4. Rank Selection\\n\")\n",
    "        print(\"Crossover selection options (1-3)\\n1. Singe-point\\n2. Two-point\\n3. Uniform\\n\")\n",
    "\n",
    "        try:\n",
    "            self.parent_selection = int(input(\"Parent selection method: \"))\n",
    "            self.crossover_selection = int(input(\"Crossover method: \"))\n",
    "\n",
    "            print(f\"Parent selection method: {self.parent_selection_techniques.get(self.parent_selection)}\") \n",
    "            print(f\"Crossover method: {self.crossover_selection_techniques.get(self.crossover_selection)}\")\n",
    "        except:\n",
    "            print(\"No option selected\")\n",
    "\n",
    "    def initialisePopulation(self):\n",
    "        \"\"\"\n",
    "        Chromosome is array of length 50\n",
    "        Index is department number, i.e, (0-49) -> (1-50)\n",
    "        Element (gene) is the number of employees assigned to deparment\n",
    "        Sum of array is always = 80 to match the distributuion of 80 employees\n",
    "\n",
    "        Appends individuals to population array\n",
    "        \"\"\"\n",
    "        for i in range(self.population_size):\n",
    "            individual = [1] * 50\n",
    "            remaining = 80 - sum(individual)\n",
    "\n",
    "            for _ in range(remaining):\n",
    "                individual[random.randint(0,49)] += 1\n",
    "\n",
    "            self.population.append(individual)\n",
    "\n",
    "    def evaluate(self, generationNumber):\n",
    "        \"\"\"\n",
    "        Evaluate and update the fitness of each solution in a given population\n",
    "        Fitness array sorted in ascending order -> lowest fitness values kept at top of list along with solution\n",
    "        \"\"\"\n",
    "        #loop through solutions and calculate fitness\n",
    "        for i in range(len(self.population)):\n",
    "            fitness = self.calcFitness(self.population[i])\n",
    "            self.fitness.append((fitness, self.population[i]))\n",
    "\n",
    "        #sort fitness list by fitness\n",
    "        self.fitness.sort(key=operator.itemgetter(0)) #sort by ascending\n",
    "\n",
    "        #update fitness\n",
    "        if self.fitness[0][0] < self.best_fitness: #lower fitness -> better solution\n",
    "            self.best_fitness = self.fitness[0][0]\n",
    "            self.best_individual = self.fitness[0][1]\n",
    "            self.best_found_at = generationNumber\n",
    "            self.patience_counter = 0\n",
    "\n",
    "    def calcFitness(self, individual):\n",
    "        \"\"\"\"\n",
    "        Fitness is determined by the weighted formula:\n",
    "            fitness = 0.8 * average_waiting_time + 0.2 * maximum_waiting_time\n",
    "\n",
    "        Importance metrics are used as weights\n",
    "        Objective is to minimise wait time therefore lower fitness is better\n",
    "        No possible invalid solution therefore fitness value is only returned\n",
    "        \"\"\"\n",
    "        #run simulator to get wait times of given assignment \n",
    "        _x, wait_times_per_service = service_simulator.init_and_simulate(individual)\n",
    "        \n",
    "        sums = [np.sum(wait_times_per_service[j]) for j in range(len(wait_times_per_service))] #holds the sum of the waiting time for each service\n",
    "        counts = [len(wait_times_per_service[j]) for j in range(len(wait_times_per_service))] #counts the number of waiting times for each service\n",
    "        maximums= [np.max(wait_times_per_service[j]) for j in range(len(wait_times_per_service))] #holds maximum waiting time for each service\n",
    "        \n",
    "        #mean and max waiting time\n",
    "        average_waiting_time = np.sum(sums)/np.sum(counts)\n",
    "        maximum_waiting_time = np.max(maximums)\n",
    "\n",
    "        fitness = 0.8 * average_waiting_time + 0.2 * maximum_waiting_time\n",
    "\n",
    "        return fitness\n",
    "    \n",
    "    def elitism(self):\n",
    "        \"\"\"\n",
    "        Parent selection via elitism and random selection\n",
    "        Number of elites -> best quarter of the population\n",
    "        Number of parents -> Double number of elites\n",
    "\n",
    "        First portion of parent list are best individuals\n",
    "        The remainder is randomly selected\n",
    "        \"\"\"\n",
    "        num_elites = self.population_size//4 \n",
    "        num_parents = num_elites*2\n",
    "\n",
    "        self.parents = [ft[1] for ft in self.fitness[:num_elites]]  #x elite individuals with best fitness\n",
    "        other_parents_indices = random.sample(range(num_elites,num_parents), num_parents-num_elites)\n",
    "\n",
    "        for i in other_parents_indices:\n",
    "            self.parents.append(self.fitness[i][1]) #selecting the individual\n",
    "\n",
    "    def roulette_wheel(self):\n",
    "        \"\"\"\n",
    "        Since lower fitness == better -> probability selection is inversely proporional to fitness value\n",
    "        Invert fitness values so that individuals with lower fitness have higher scores\n",
    "\n",
    "        For a parent to be selected -> randomly pick a number between 0 and 1 then\n",
    "        Iterate through the population, sum the probabilities and select the first individual whose\n",
    "        cumulative probability exceeds the random number\n",
    "        \"\"\"\n",
    "        inverted_fitness = [1/ft[0] for ft in self.fitness]\n",
    "        total_inverted_fitness = sum(inverted_fitness)\n",
    "        probabilities = [x/total_inverted_fitness for x in inverted_fitness]\n",
    "\n",
    "        for _ in range(self.num_parents):\n",
    "            rand = random.uniform(0, sum(probabilities))\n",
    "            cumulative_sum = 0\n",
    "\n",
    "            for i,prob in enumerate(probabilities):\n",
    "                cumulative_sum += prob\n",
    "\n",
    "                if rand < cumulative_sum:\n",
    "                    self.parents.append(self.fitness[i][1])\n",
    "                    break\n",
    "\n",
    "    def tournament_selection(self):\n",
    "        \"\"\"\n",
    "        Groups of individuals are randomly selected and the fittest individual from each group\n",
    "        is selected to be the parent \n",
    "        \"\"\"\n",
    "        for _ in range(self.num_parents):\n",
    "            tournament = random.sample(range(len(self.fitness)), self.tournament_size)\n",
    "            best_individual = min(tournament, key=lambda x: self.fitness[x])\n",
    "            self.parents.append(self.fitness[best_individual][1])\n",
    "\n",
    "    def rank_selection(self):\n",
    "        \"\"\"\n",
    "        Individuals are ranked based on fitness and their selection probability is proportional to their\n",
    "        rank rather than their raw fitness\n",
    "        -> Reduces the impact of very fit individuals dominating the selection\n",
    "        \"\"\"\n",
    "        #rank based on fitness\n",
    "        ranked_individuals = sorted(range(len(self.fitness)), key=lambda x: self.fitness[x])\n",
    "\n",
    "        #assign selection probability based on rank\n",
    "        total_rank = sum(range(1,len(self.fitness) + 1))\n",
    "        probabilities = [(i+1)/total_rank for i in range(len(self.fitness))]\n",
    "\n",
    "        for _ in range(self.num_parents):\n",
    "            rand = random.uniform(0, sum(probabilities))\n",
    "            cumulative_sum = 0\n",
    "\n",
    "            for i, prob in enumerate(probabilities):\n",
    "                cumulative_sum += prob\n",
    "\n",
    "                if rand < cumulative_sum:\n",
    "                    self.parents.append(self.fitness[ranked_individuals[i]][1])\n",
    "                    break\n",
    "    \n",
    "    def selectParents(self):\n",
    "        match self.parent_selection:\n",
    "            case 1:\n",
    "                self.elitism()\n",
    "            case 2:\n",
    "                self.roulette_wheel()\n",
    "            case 3:\n",
    "                self.tournament_selection()\n",
    "            case 4:\n",
    "                self.rank_selection()\n",
    "\n",
    "    def modifyChild(self, child):\n",
    "        \"\"\"\n",
    "        -> Consideration of edge cases\n",
    "        -> Sum of children (employees) must equal 80 after crossover\n",
    "        -> if sum > 80 then decrement\n",
    "        -> if sum < 80 then increment\n",
    "        -> else no modification needed \n",
    "        \"\"\"\n",
    "        max_sum = 80\n",
    "\n",
    "        if sum(child) > max_sum:\n",
    "            diff = sum(child) - max_sum\n",
    "\n",
    "            while diff > 0:\n",
    "                rand = random.randint(0,49)\n",
    "\n",
    "                if child[rand] > 1:\n",
    "                    child[rand] -= 1\n",
    "                    diff -= 1\n",
    "        elif sum(child) < max_sum:\n",
    "            diff = max_sum - sum(child)\n",
    "\n",
    "            while diff > 0:\n",
    "                child[random.randint(0,49)] += 1\n",
    "                diff -= 1\n",
    "        else:\n",
    "            return child #unmodified child\n",
    "        return child #modified child\n",
    "\n",
    "    def singlePointCrossover(self, parent1, parent2):\n",
    "        \"\"\" \n",
    "        -> randomly select single point in parent\n",
    "        -> divide parent chromosome at selected point\n",
    "        -> swap parent tails to form new children\n",
    "        \"\"\"\n",
    "        cp = random.randint(0,len(parent1)-1)\n",
    "\n",
    "        tmp1 = parent1[cp:]\n",
    "        tmp2 = parent2[cp:]\n",
    "        child1 = parent1[:cp]\n",
    "        child2 = parent2[:cp]\n",
    "\n",
    "        child1.extend(tmp2)\n",
    "        child2.extend(tmp1)\n",
    "\n",
    "        child1 = self.modifyChild(child1)\n",
    "        child2 = self.modifyChild(child2)\n",
    "\n",
    "        return child1, child2\n",
    "\n",
    "    def twoPointCrossover(self, parent1, parent2):\n",
    "        \"\"\"\n",
    "        -> cp1 must always be smaller than cp2\n",
    "        -> cp1 cannot be the largest index in the list\n",
    "        -> indices must be selected within a valid range to prevent IndexOutOfBounds error\n",
    "        -> swap segments of arrays to produce offspring\n",
    "        \"\"\"\n",
    "        cp1 = random.randint(0,(len(parent1)-1)-1)\n",
    "        cp2 = random.randint(cp1+1,len(parent1)-1)\n",
    "\n",
    "        segment1 = parent1[cp1:cp2+1]\n",
    "        segment2 = parent2[cp1:cp2+1]\n",
    "\n",
    "        leftsegment1 = parent1[:cp1]\n",
    "        leftsegment2 = parent2[:cp1]\n",
    "        rightsegment1 = parent1[cp2+1:]\n",
    "        rightsegment2 = parent2[cp2+1:]\n",
    "\n",
    "        child1 = leftsegment1 + segment2 + rightsegment1\n",
    "        child2 = leftsegment2 + segment1 + rightsegment2\n",
    "\n",
    "        child1 = self.modifyChild(child1)\n",
    "        child2 = self.modifyChild(child2)\n",
    "\n",
    "        return child1, child2\n",
    "\n",
    "    def uniformCrossover(self, parent1, parent2):\n",
    "        \"\"\" \n",
    "        Each child gene has a 50% chance to be selected from either parent\n",
    "        \"\"\"\n",
    "        child1 = []\n",
    "        child2 = []\n",
    "\n",
    "        for i in range(len(parent1)):\n",
    "            k = random.uniform(0,1)\n",
    "\n",
    "            if k > 0.5: # select from parent1 first\n",
    "                child1.append(parent1[i])\n",
    "                child2.append(parent2[i])\n",
    "            else:\n",
    "                child1.append(parent2[i])\n",
    "                child2.append(parent1[i])\n",
    "\n",
    "        child1 = self.modifyChild(child1)\n",
    "        child2 = self.modifyChild(child2)\n",
    "\n",
    "        return child1, child2\n",
    "\n",
    "    def crossover(self, parent1, parent2):\n",
    "        match self.crossover_selection:\n",
    "            case 1:\n",
    "                child1, child2 = self.singlePointCrossover(parent1, parent2)\n",
    "            case 2:\n",
    "                child1, child2 = self.twoPointCrossover(parent1, parent2)\n",
    "            case 3:\n",
    "                child1, child2 = self.uniformCrossover(parent1, parent2)\n",
    "        \n",
    "        return child1, child2\n",
    "\n",
    "    def mutate(self, child):\n",
    "        \"\"\"\n",
    "        Perform swap mutation on genes\n",
    "        Each child gene has a probability chance to be swapped with another gene\n",
    "        \"\"\"\n",
    "        for _ in range(len(child)):\n",
    "            k = random.uniform(0,1)\n",
    "\n",
    "            if k > self.mutation_rate:\n",
    "                notSwapped = True\n",
    "                while notSwapped:\n",
    "                    sp1 = random.randint(0,len(child)-1)\n",
    "                    sp2 = random.randint(0,len(child)-1)\n",
    "\n",
    "                    if sp1 != sp2:\n",
    "                        child[sp1], child[sp2] = child[sp2], child[sp1] # swap\n",
    "                        notSwapped = False\n",
    "\n",
    "        return child\n",
    "\n",
    "    def run(self):\n",
    "        for g in range(self.num_generations):\n",
    "            self.evaluate(g)\n",
    "            self.selectParents()\n",
    "\n",
    "            new_population = []\n",
    "\n",
    "            #crossover\n",
    "            for i in range(self.population_size):\n",
    "                [parent1Indx ,parent2Indx] = random.sample(range(0,len(self.parents)), 2)\n",
    "                child1, child2 = self.crossover(self.parents[parent1Indx], self.parents[parent2Indx])\n",
    "                new_population.append(child1)\n",
    "                new_population.append(child2)\n",
    "\n",
    "            #mutate\n",
    "            for i in range(len(new_population)):\n",
    "                new_population[i] = self.mutate(new_population[i])\n",
    "\n",
    "            #track fitness\n",
    "            self.patience_counter += 1\n",
    "            self.list_of_best_fitness.append(self.best_fitness)\n",
    "\n",
    "            if self.patience_counter == self.patience:\n",
    "                print(f\"Stopped after {g} generations\\n\")\n",
    "                break\n",
    "            else:\n",
    "                if g%10 == 0 and self.verbose:\n",
    "                    print(f\"Generation: {g} Best Fitness so far: {self.best_fitness} Found at generation: {self.best_found_at}\")\n",
    "\n",
    "                self.population = new_population\n",
    "                self.fitness = []\n",
    "                self.parents = []\n",
    "        \n",
    "        print(f\"Best individual is: {self.best_individual}\\nFitness value is: {self.best_fitness}\\nFound at generation: {self.best_found_at}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Algorithm params"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "population_size = 50\n",
    "num_generations = 100\n",
    "mutation_rate = 0.9\n",
    "patience = 10\n",
    "verbose = False\n",
    "\n",
    "ga = GeneticAlgorithm(population_size, num_generations, mutation_rate, patience, verbose)\n",
    "\n",
    "ga.run()\n",
    "\n",
    "plt.plot(ga.list_of_best_fitness)\n",
    "plt.xlabel(\"Generation\")\n",
    "plt.ylabel(\"Best Fitness\")\n",
    "plt.title(\"Best Fitness over Generations (Lower = Better)\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Test performance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "run_means = []\n",
    "run_maxs = []\n",
    "\n",
    "def testPerformance(run):\n",
    "    print(f\"Run: {run}\")\n",
    "\n",
    "    employee_setting = ga.best_individual\n",
    "\n",
    "    means = [0 for _ in range(10)]\n",
    "    maxs = [0 for _ in range(10)]\n",
    "\n",
    "    for _ in range(10):\n",
    "        _x, wait_times_per_service = service_simulator.init_and_simulate(employee_setting)\n",
    "        sums = [np.sum(wait_times_per_service[j]) for j in range(len(wait_times_per_service))]\n",
    "        counts = [len(wait_times_per_service[j]) for j in range(len(wait_times_per_service))]\n",
    "        maximums= [np.max(wait_times_per_service[j]) for j in range(len(wait_times_per_service))]\n",
    "        means[_] =  np.sum(sums)/np.sum(counts)\n",
    "        maxs[_] = np.max(maximums)\n",
    "\n",
    "    run_means.append(np.mean(means))\n",
    "    run_maxs.append(np.mean(maxs))\n",
    "\n",
    "    print(f\"Mean waiting time averaged over 10 simulations: {np.mean(means)}\")\n",
    "    print(f\"Max waiting time  averaged over 10 simulations: {np.mean(maxs)}\\n\")\n",
    "\n",
    "for i in range(1,11):\n",
    "    testPerformance(i)\n",
    "\n",
    "print(f\"Average mean wait time over 10 runs: {np.sum(run_means)/10}\")\n",
    "print(f\"Average max wait time over 10 runs: {np.sum(run_maxs)/10}\\n\")\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
